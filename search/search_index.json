{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Stock Analysis","title":"Home"},{"location":"#welcome-to-stock-analysis","text":"","title":"Welcome to Stock Analysis"},{"location":"description/","text":"Momentum Portfolio Many trading strategies that the traders use, one of the most popular strategies is the momentum strategy. Traders measure momentum in many different ways to identify opportunity pockets. The core idea across all these strategies remains the same i.e to identify momentum and ride the wave. What is Momentum \u2018Momentum\u2019 is a physics term, it refers to the quantity of motion that an object has. If you look at this definition in the context of stocks markets, then everything remains the same, except that you will have to replace \u2018object\u2019 by stocks or the index. Simply put, momentum is the rate of change of returns of the stock or the index. If the rate of change of returns is high, then the momentum is considered high and if the rate of change of returns is low, the momentum is considered low. This leads us to to the next obvious question i.e is what is the rate of change of returns?. The rate of change of return, as it states the return generated (or eroded) between two reference time period. For the sake of this discussion, let\u2019s stick to the rate of change of return on an end of day basis. So in this context, the rate of change of returns simply means the speed at which the daily return of the stock varies. Momentum Portfolio Before we discuss this strategy,below few things need to be taken into consideration \u2013 The agenda here is to highlight how a momentum portfolio can be set up. However, this is not the only way to build a momentum portfolio You will need programming skills to implement this strategy or to build any other momentum strategy. Given the above, here is a systematic guide to building a \u2018Momentum Portfolio\u2019. Step 1 \u2013 Define your stock universe As you may know, there are close to 4000 listed stocks on BSE and about 1800 on NSE. This includes highly valuable companies like TCS and absolute thuds such as pretty much all the Z category stocks on BSE. Companies such as these form the two extreme ends of the spectrum. The question is, do have to track all these stocks to build a momentum portfolio? Not really, doing so would be a waste of time. One has to filter out the stocks and create something called as the \u2018tracking universe\u2019. The tracking universe will consist of a large basket of stocks within which we will pick stocks to constitute the momentum portfolio. This means the momentum portfolio will always be a subset of the tracking universe. The tracking universe can be quite straightforward \u2013 it can be the Nifty 50 stocks or the BSE 500 stocks. Therefore, the momentum portfolio will always be a subset of either the Nifty 50 or BSE 500 stocks. Keeping the BSE 500 stocks as your tracking universe is a good way to start, however, if you feel a little adventurous, you can custom create your tracking universe. Custom creation can be on any parameter \u2013 for example, out of the entire 1800 stocks on NSE, I could use a filter to weed out stocks, which has a market cap of at least 1000Crs. This filter alone will shrink the list to a much smaller, manageable set. Further, I may add other criteria such as the price of the stock should be less than 2000. So on and so forth. I am just randomly sharing few filter ideas, but you get the point. Using the custom creation techniques helps you filter out and build a tracking universe that exactly matches your requirement. Lastly, from my personal experience, I would suggest you have at least 150-200 stocks in your tracking universe if you wish to build a momentum portfolio of 12-15 stock. Step 2 \u2013 Set up the data Assuming your tracking universe is set up, you are now good to proceed to the 2nd step. In this step, you need to ensure you get the closing prices of all the stocks in your tracking universe. Ensure the data set that you have is clean and adjusted for corporate actions like the bonus issue, splits, special dividends, and other corporate actions. Clean data is the key building block to any trading strategy. There are plenty of data sources from where you can download the data free, including the NSE/BSE websites.Here we used yahoo finance API for collecting daily stock price data. The question is \u2013 what is the look back period? How many historical data points are required? To run this strategy, you only need 1-year data point. For example, today is 2nd March 2021, then I\u2019d need data point from 1st March 2020 to 2nd March 2021. Please note, once you have the data points for last one-year set, you can update this on a daily basis, which means the daily closing prices are recorded. Step 3 \u2013 Calculate returns This is a crucial part of the strategy; in this step, we calculate the returns of all the stocks in the tracking universe. As you may have already guessed, we calculate the return to get a sense of the momentum in each of the stocks. As we discussed earlier in this chapter, one can calculate the returns on any time frequency, be it daily/weekly/monthly or even yearly returns. We will stick to yearly returns for the sake of this discussion, however, please note; you can add your own twist to the entire strategy and calculate the returns on any time frequency you wish. Instead of yearly, you could calculate the half-yearly, monthly, or even fortnightly returns. So, at this stage, you should have a tracking universe consisting of about 150-200 stocks. All these stocks should have historical data for at least 1 year. Further, you need to calculate the yearly return for each of these stocks in your tracking universe. Return = [ending value/starting value]-1 \\= [1244.55/1435.55]-1 \\= -13.31% Quite straightforward, I guess. Step 4 \u2013 Rank the returns Once the returns are calculated, you need to rank the returns from the highest to the lowest returns. So what does this ranking tell us? If you think about it, the ranking reorders our tracking universe to give us a list of stocks from the highest return stock to the lowest. Step 5 \u2013 Create the portfolio A typical tracking universe will have about 150-200 stocks, and with the help of the previous step, we would have reordered the tracking universe. Now, with the reordered tracking universe, we are good to create a momentum portfolio. Remember, momentum is the rate of change of return and the return itself is measured on a yearly basis. A good momentum portfolio contains about 10-12 stocks. I\u2019m personally comfortable with up to 15 stocks in the portfolio, not more than that. For the sake of this discussion, let us assume that we are building a 12 stocks momentum portfolio. The momentum portfolio is now simply the top 12 stocks in the reordered tracking universe. In other words, we buy all the stocks starting from rank 1 to rank 12. In the example we were dealing with.The rest of the stocks would not constitute the portfolio but will continue to remain in the tracking universe. What is the logic of selecting this subset of stocks within the tracking universe, you may ask? Well, read this carefully \u2013 if the stock has done well (in terms of returns generated) for the last 12 months, then it implies that the stock has good momentum for the defined time frame. The expectation is that this momentum will continue onto the 13th month as well, and therefore the stock will continue to generate higher returns. So if you were to buy such stocks, then you are to benefit from the expected momentum in the stock. Clearly, this is a claim. I do not have data to back this, but I have personally used this exact technique for a couple of years with decent success. It is easy to back-test this strategy, and I encourage you to do so. Once the momentum portfolio stocks are identified, the idea is to buy all the momentum stocks in equal proportion. So if the capital available is Rs.200,000/- and there are 12 stocks, then the idea is to buy Rs.16,666/- worth of each stock (200,000/12). By doing so, you create an equally weighted momentum portfolio. Of course, you can tweak the weights to create a skewed portfolio, there is no problem with it, but then you need to have a solid reason for doing so. This reason should come from backtested results. If you like to experiment with skewed portfolios, here are few ideas \u2013 50% of capital allocation across the top 5 momentum stocks (rank 1 to 5), and 50% across the remaining 7 stocks Top 3 stocks get 40% and the balance 60% across 9 stocks If you are a contrarian and expect the lower rank stocks to perform better than the higher rank stocks, then allocate more to last 5 stocks So on and so forth. Ideally, the approach to capital allocation should come from your backtesting process, this also means you will have to backtest various capital allocation techniques to figure out which works well for you. Step 6 \u2013 Rebalance the portfolio So far, we have created a tracking universe, calculated the 12-month returns, ranked the stocks in terms of the 12-month returns, and created a momentum portfolio by buying the top 12 stocks. The momentum portfolio was built based on the 12-month performance, with a hope that it will continue to showcase the same performance for the 13th month. There are few assumptions here \u2013 The portfolio is created and bought on the 1st trading day of the month The above implies that all the number crunching happens on the last day of the month, post-market close Once the portfolio is created and bought, you hold on to the stocks till the last day of the month Now the question is, what really happens at the end of the month? At the end of the month, you re-run the ranking engine and figure out the top 10 or 12 stocks which have performed well over the last 12 month. Do note, at any point we consider the latest 12 months of data. So, we now buy the stocks from rank 1 to 12, just like the way we did in the previous month. From my experience, chances are that out of the initial portfolio, only a hand full of stocks would have changed positions. So based on the list, you sell the stocks which no longer belongs in the portfolio and buy the new stocks which have featured in the latest momentum portfolio. In essence, you rebalance the portfolio and you do this at the end of every month. So on and so forth. 16.4 \u2013 Momentum Portfolio variations The returns have been calculated on a 12-month portfolio and the stocks are held for a month. However, you don\u2019t have to stick to this. You can try out various options, like \u2013 Calculate return and rank the stocks based on their monthly performance and hold the portfolio for the month Calculate return and rank the stocks based on fortnightly performance and hold the portfolio for 15 days Rank on a weekly basis and hold for a week Calculate on a daily basis and even do an intraday momentum portfolio As you can see, the options are plenty and it\u2019s only restricted by your imagination. If you think about what we have discussed so far, the momentum portfolio is price based. However, you can build a fundamental based momentum strategy as well. Here are a few ideas \u2013 Build a tracking universe of fundamentally good stocks Note the difference in quarterly sales number (% wise) Rank the stocks based on quarterly sales. Company with the highest jump in sales gets rank one and so on Buy the top 10 \u2013 12 stocks Rebalance at the end of the quarter You can do this on any fundamental parameter \u2013 EPS growth, profit margin, EBITDA margin etc. The beauty of these strategies is that the data is available, hence backtesting gets a lot easier. 16.5 \u2013 Word of caution As good as it may seem, the price based momentum strategy works well only when the market is trending up. When the markets turn choppy, the momentum strategy performs poorly, and when the markets go down, the momentum portfolio bleeds heavier than the markets itself. Understanding the strategy\u2019s behavior with respect to market cycle is quite crucial to the eventual success of this portfolio. I learned it the hard way. I had a great run with this strategy in 2009 and \u201910 but took a bad hit in 2011. So before you execute this strategy, do your homework (backtesting) right. Having said all of that let me reassure you \u2013 a price based momentum strategy, if implemented in the right market cycle can give you great returns, in fact, better more often than not, better than the market returns.","title":"Momentum Portfolio"},{"location":"description/#momentum-portfolio","text":"","title":"Momentum Portfolio"},{"location":"description/#many-trading-strategies-that-the-traders-use-one-of-the-most-popular-strategies-is-the-momentum-strategy-traders-measure-momentum-in-many-different-ways-to-identify-opportunity-pockets-the-core-idea-across-all-these-strategies-remains-the-same-ie-to-identify-momentum-and-ride-the-wave","text":"","title":"Many trading strategies that the traders use, one of the most popular strategies is the momentum strategy. Traders measure momentum in many different ways to identify opportunity pockets. The core idea across all these strategies remains the same i.e to identify momentum and ride the wave."},{"location":"description/#what-is-momentum","text":"\u2018Momentum\u2019 is a physics term, it refers to the quantity of motion that an object has. If you look at this definition in the context of stocks markets, then everything remains the same, except that you will have to replace \u2018object\u2019 by stocks or the index. Simply put, momentum is the rate of change of returns of the stock or the index. If the rate of change of returns is high, then the momentum is considered high and if the rate of change of returns is low, the momentum is considered low. This leads us to to the next obvious question i.e is what is the rate of change of returns?. The rate of change of return, as it states the return generated (or eroded) between two reference time period. For the sake of this discussion, let\u2019s stick to the rate of change of return on an end of day basis. So in this context, the rate of change of returns simply means the speed at which the daily return of the stock varies.","title":"What is Momentum"},{"location":"description/#momentum-portfolio_1","text":"Before we discuss this strategy,below few things need to be taken into consideration \u2013 The agenda here is to highlight how a momentum portfolio can be set up. However, this is not the only way to build a momentum portfolio You will need programming skills to implement this strategy or to build any other momentum strategy. Given the above, here is a systematic guide to building a \u2018Momentum Portfolio\u2019.","title":"Momentum Portfolio"},{"location":"description/#step-1-define-your-stock-universe","text":"As you may know, there are close to 4000 listed stocks on BSE and about 1800 on NSE. This includes highly valuable companies like TCS and absolute thuds such as pretty much all the Z category stocks on BSE. Companies such as these form the two extreme ends of the spectrum. The question is, do have to track all these stocks to build a momentum portfolio? Not really, doing so would be a waste of time. One has to filter out the stocks and create something called as the \u2018tracking universe\u2019. The tracking universe will consist of a large basket of stocks within which we will pick stocks to constitute the momentum portfolio. This means the momentum portfolio will always be a subset of the tracking universe. The tracking universe can be quite straightforward \u2013 it can be the Nifty 50 stocks or the BSE 500 stocks. Therefore, the momentum portfolio will always be a subset of either the Nifty 50 or BSE 500 stocks. Keeping the BSE 500 stocks as your tracking universe is a good way to start, however, if you feel a little adventurous, you can custom create your tracking universe. Custom creation can be on any parameter \u2013 for example, out of the entire 1800 stocks on NSE, I could use a filter to weed out stocks, which has a market cap of at least 1000Crs. This filter alone will shrink the list to a much smaller, manageable set. Further, I may add other criteria such as the price of the stock should be less than 2000. So on and so forth. I am just randomly sharing few filter ideas, but you get the point. Using the custom creation techniques helps you filter out and build a tracking universe that exactly matches your requirement. Lastly, from my personal experience, I would suggest you have at least 150-200 stocks in your tracking universe if you wish to build a momentum portfolio of 12-15 stock.","title":"Step 1 \u2013 Define your stock universe"},{"location":"description/#step-2-set-up-the-data","text":"Assuming your tracking universe is set up, you are now good to proceed to the 2nd step. In this step, you need to ensure you get the closing prices of all the stocks in your tracking universe. Ensure the data set that you have is clean and adjusted for corporate actions like the bonus issue, splits, special dividends, and other corporate actions. Clean data is the key building block to any trading strategy. There are plenty of data sources from where you can download the data free, including the NSE/BSE websites.Here we used yahoo finance API for collecting daily stock price data. The question is \u2013 what is the look back period? How many historical data points are required? To run this strategy, you only need 1-year data point. For example, today is 2nd March 2021, then I\u2019d need data point from 1st March 2020 to 2nd March 2021. Please note, once you have the data points for last one-year set, you can update this on a daily basis, which means the daily closing prices are recorded.","title":"Step 2 \u2013 Set up the data"},{"location":"description/#step-3-calculate-returns","text":"This is a crucial part of the strategy; in this step, we calculate the returns of all the stocks in the tracking universe. As you may have already guessed, we calculate the return to get a sense of the momentum in each of the stocks. As we discussed earlier in this chapter, one can calculate the returns on any time frequency, be it daily/weekly/monthly or even yearly returns. We will stick to yearly returns for the sake of this discussion, however, please note; you can add your own twist to the entire strategy and calculate the returns on any time frequency you wish. Instead of yearly, you could calculate the half-yearly, monthly, or even fortnightly returns. So, at this stage, you should have a tracking universe consisting of about 150-200 stocks. All these stocks should have historical data for at least 1 year. Further, you need to calculate the yearly return for each of these stocks in your tracking universe. Return = [ending value/starting value]-1 \\= [1244.55/1435.55]-1 \\= -13.31% Quite straightforward, I guess.","title":"Step 3 \u2013 Calculate returns"},{"location":"description/#step-4-rank-the-returns","text":"Once the returns are calculated, you need to rank the returns from the highest to the lowest returns. So what does this ranking tell us? If you think about it, the ranking reorders our tracking universe to give us a list of stocks from the highest return stock to the lowest.","title":"Step 4 \u2013 Rank the returns"},{"location":"description/#step-5-create-the-portfolio","text":"A typical tracking universe will have about 150-200 stocks, and with the help of the previous step, we would have reordered the tracking universe. Now, with the reordered tracking universe, we are good to create a momentum portfolio. Remember, momentum is the rate of change of return and the return itself is measured on a yearly basis. A good momentum portfolio contains about 10-12 stocks. I\u2019m personally comfortable with up to 15 stocks in the portfolio, not more than that. For the sake of this discussion, let us assume that we are building a 12 stocks momentum portfolio. The momentum portfolio is now simply the top 12 stocks in the reordered tracking universe. In other words, we buy all the stocks starting from rank 1 to rank 12. In the example we were dealing with.The rest of the stocks would not constitute the portfolio but will continue to remain in the tracking universe. What is the logic of selecting this subset of stocks within the tracking universe, you may ask? Well, read this carefully \u2013 if the stock has done well (in terms of returns generated) for the last 12 months, then it implies that the stock has good momentum for the defined time frame. The expectation is that this momentum will continue onto the 13th month as well, and therefore the stock will continue to generate higher returns. So if you were to buy such stocks, then you are to benefit from the expected momentum in the stock. Clearly, this is a claim. I do not have data to back this, but I have personally used this exact technique for a couple of years with decent success. It is easy to back-test this strategy, and I encourage you to do so. Once the momentum portfolio stocks are identified, the idea is to buy all the momentum stocks in equal proportion. So if the capital available is Rs.200,000/- and there are 12 stocks, then the idea is to buy Rs.16,666/- worth of each stock (200,000/12). By doing so, you create an equally weighted momentum portfolio. Of course, you can tweak the weights to create a skewed portfolio, there is no problem with it, but then you need to have a solid reason for doing so. This reason should come from backtested results. If you like to experiment with skewed portfolios, here are few ideas \u2013 50% of capital allocation across the top 5 momentum stocks (rank 1 to 5), and 50% across the remaining 7 stocks Top 3 stocks get 40% and the balance 60% across 9 stocks If you are a contrarian and expect the lower rank stocks to perform better than the higher rank stocks, then allocate more to last 5 stocks So on and so forth. Ideally, the approach to capital allocation should come from your backtesting process, this also means you will have to backtest various capital allocation techniques to figure out which works well for you.","title":"Step 5 \u2013 Create the portfolio"},{"location":"description/#step-6-rebalance-the-portfolio","text":"So far, we have created a tracking universe, calculated the 12-month returns, ranked the stocks in terms of the 12-month returns, and created a momentum portfolio by buying the top 12 stocks. The momentum portfolio was built based on the 12-month performance, with a hope that it will continue to showcase the same performance for the 13th month. There are few assumptions here \u2013 The portfolio is created and bought on the 1st trading day of the month The above implies that all the number crunching happens on the last day of the month, post-market close Once the portfolio is created and bought, you hold on to the stocks till the last day of the month Now the question is, what really happens at the end of the month? At the end of the month, you re-run the ranking engine and figure out the top 10 or 12 stocks which have performed well over the last 12 month. Do note, at any point we consider the latest 12 months of data. So, we now buy the stocks from rank 1 to 12, just like the way we did in the previous month. From my experience, chances are that out of the initial portfolio, only a hand full of stocks would have changed positions. So based on the list, you sell the stocks which no longer belongs in the portfolio and buy the new stocks which have featured in the latest momentum portfolio. In essence, you rebalance the portfolio and you do this at the end of every month. So on and so forth.","title":"Step 6 \u2013 Rebalance the portfolio"},{"location":"description/#164-momentum-portfolio-variations","text":"The returns have been calculated on a 12-month portfolio and the stocks are held for a month. However, you don\u2019t have to stick to this. You can try out various options, like \u2013 Calculate return and rank the stocks based on their monthly performance and hold the portfolio for the month Calculate return and rank the stocks based on fortnightly performance and hold the portfolio for 15 days Rank on a weekly basis and hold for a week Calculate on a daily basis and even do an intraday momentum portfolio As you can see, the options are plenty and it\u2019s only restricted by your imagination. If you think about what we have discussed so far, the momentum portfolio is price based. However, you can build a fundamental based momentum strategy as well. Here are a few ideas \u2013 Build a tracking universe of fundamentally good stocks Note the difference in quarterly sales number (% wise) Rank the stocks based on quarterly sales. Company with the highest jump in sales gets rank one and so on Buy the top 10 \u2013 12 stocks Rebalance at the end of the quarter You can do this on any fundamental parameter \u2013 EPS growth, profit margin, EBITDA margin etc. The beauty of these strategies is that the data is available, hence backtesting gets a lot easier.","title":"16.4 \u2013 Momentum Portfolio variations"},{"location":"description/#165-word-of-caution","text":"As good as it may seem, the price based momentum strategy works well only when the market is trending up. When the markets turn choppy, the momentum strategy performs poorly, and when the markets go down, the momentum portfolio bleeds heavier than the markets itself. Understanding the strategy\u2019s behavior with respect to market cycle is quite crucial to the eventual success of this portfolio. I learned it the hard way. I had a great run with this strategy in 2009 and \u201910 but took a bad hit in 2011. So before you execute this strategy, do your homework (backtesting) right. Having said all of that let me reassure you \u2013 a price based momentum strategy, if implemented in the right market cycle can give you great returns, in fact, better more often than not, better than the market returns.","title":"16.5 \u2013 Word of caution"},{"location":"reference/indicators_docs/","text":"Perform Indicator operation which are based on specific metrics used to study the performance of desired stock/company. Parameters: Name Type Description Default path [str, optional] Path to company yaml/json. Either path or company_name can be used. required company_name [List, optional] List of company name. If path is used then this is obsolete required Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') Methods ema_crossover_detail_indicator ( self , ema_canditate = ( 5 , 13 , 26 ), save = True , export_path = '.' , verbosity = 1 ) Exponential moving average for crossover triple period technique Parameters: Name Type Description Default ema_canditate Tuple[int, int, int] Three Period (or days) to calculate EMA. Defaults to (5, 13, 26). (5, 13, 26) save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame Results is based on crossover ema and detailed metrics Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_crossover_detail_indicator((5,10,020), '01/06/2020') Source code in stock_analysis/indicator.py def ema_crossover_detail_indicator ( self , ema_canditate : Tuple [ int , int , int ] = ( 5 , 13 , 26 ), save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Exponential moving average for crossover triple period technique Args: ema_canditate (Tuple[int, int, int], optional): Three Period (or days) to calculate EMA. Defaults to (5, 13, 26). save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: Results is based on crossover ema and detailed metrics Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_crossover_detail_indicator((5,10,020), '01/06/2020') ``` \"\"\" logger . info ( \"Performing EMA Indicator Task\" ) ema_short = self . _ema_indicator_n3 ( ema_canditate = ema_canditate , verbosity = verbosity ) logger . info ( \"Extarcting detail company quote data\" ) batch_company_quote = pd . DataFrame () with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : company_quote = pool . map ( self . unit_quote_retrive , ema_short [ \"company\" ]) for single_company_quote in company_quote : if isinstance ( single_company_quote , pd . DataFrame ): batch_company_quote = batch_company_quote . append ( single_company_quote ) batch_company_quote = batch_company_quote . reset_index () . rename ( columns = { \"index\" : \"company\" } ) batch_company_quote = batch_company_quote [ [ \"company\" , \"longName\" , \"price\" , \"regularMarketVolume\" , \"marketCap\" , \"bookValue\" , \"priceToBook\" , \"averageDailyVolume3Month\" , \"averageDailyVolume10Day\" , \"fiftyTwoWeekLowChange\" , \"fiftyTwoWeekLowChangePercent\" , \"fiftyTwoWeekRange\" , \"fiftyTwoWeekHighChange\" , \"fiftyTwoWeekHighChangePercent\" , \"fiftyTwoWeekLow\" , \"fiftyTwoWeekHigh\" , ] ] batch_company_quote [ \"company\" ] = batch_company_quote [ \"company\" ] . str . replace ( \".NS\" , \"\" ) ema_quote = ema_short . merge ( batch_company_quote , on = \"company\" , validate = \"1:1\" ) if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { ema_quote . head () } \" ) if save is not False : ema_quote . to_csv ( f \" { export_path } /ema_crossover_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } - { str ( ema_canditate [ 2 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Exported at { export_path } /ema_crossover_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } - { str ( ema_canditate [ 2 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" ) else : return ema_quote ema_detail_indicator ( self , ema_canditate = ( 50 , 200 ), cutoff_date = 'today' , save = True , export_path = '.' , verbosity = 1 ) Exponential moving average based on desired two period (or no of days) with additional info which include: regularMarketVolume, marketCap, bookValue, priceToBook, averageDailyVolume3Month, averageDailyVolume10Day, fiftyTwoWeekLowChange, fiftyTwoWeekLowChangePercent, fiftyTwoWeekRange, fiftyTwoWeekHighChange, fiftyTwoWeekHighChangePercent, fiftyTwoWeekLow, fiftyTwoWeekHigh Parameters: Name Type Description Default ema_canditate Tuple[int, int] Two number used two calculate EMA. Defaults to (50, 200). (50, 200) cutoff_date Union[str, datetime.datetime] Desired date till which to calculate ema. Defaults to \"today\". 'today' save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame EMA and detailed metrics for indicators Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_detail_indicator((50,200), '01/06/2020') Source code in stock_analysis/indicator.py def ema_detail_indicator ( self , ema_canditate : Tuple [ int , int ] = ( 50 , 200 ), cutoff_date : Union [ str , datetime . datetime ] = \"today\" , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Exponential moving average based on desired two period (or no of days) with additional info which include: > regularMarketVolume, marketCap, bookValue, priceToBook, averageDailyVolume3Month, averageDailyVolume10Day, fiftyTwoWeekLowChange, fiftyTwoWeekLowChangePercent, fiftyTwoWeekRange, fiftyTwoWeekHighChange, fiftyTwoWeekHighChangePercent, fiftyTwoWeekLow, fiftyTwoWeekHigh Args: ema_canditate (Tuple[int, int], optional): Two number used two calculate EMA. Defaults to (50, 200). cutoff_date (Union[str, datetime.datetime], optional): Desired date till which to calculate ema. Defaults to \"today\". save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. Returns: EMA and detailed metrics for indicators Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_detail_indicator((50,200), '01/06/2020') ``` \"\"\" logger . info ( \"Performing EMA Indicator Task\" ) ema_short = self . ema_indicator ( ema_canditate = ema_canditate , cutoff_date = cutoff_date , save = False , verbosity = verbosity ) logger . info ( \"Extarcting detail company quote data\" ) batch_company_quote = pd . DataFrame () with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : company_quote = pool . map ( self . unit_quote_retrive , ema_short [ \"company\" ]) for single_company_quote in company_quote : if isinstance ( single_company_quote , pd . DataFrame ): batch_company_quote = batch_company_quote . append ( single_company_quote ) batch_company_quote = batch_company_quote . reset_index () . rename ( columns = { \"index\" : \"company\" } ) batch_company_quote = batch_company_quote [ [ \"company\" , \"longName\" , \"price\" , \"regularMarketVolume\" , \"marketCap\" , \"bookValue\" , \"priceToBook\" , \"averageDailyVolume3Month\" , \"averageDailyVolume10Day\" , \"fiftyTwoWeekLowChange\" , \"fiftyTwoWeekLowChangePercent\" , \"fiftyTwoWeekRange\" , \"fiftyTwoWeekHighChange\" , \"fiftyTwoWeekHighChangePercent\" , \"fiftyTwoWeekLow\" , \"fiftyTwoWeekHigh\" , ] ] batch_company_quote [ \"company\" ] = batch_company_quote [ \"company\" ] . str . replace ( \".NS\" , \"\" ) ema_quote = ema_short . merge ( batch_company_quote , on = \"company\" , validate = \"1:1\" ) if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { ema_quote . head () } \" ) if save is not False : ema_quote . to_csv ( f \" { export_path } /ema_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Exported at { export_path } /ema_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" ) else : return ema_quote ema_indicator ( self , ema_canditate = ( 50 , 200 ), cutoff_date = 'today' , save = True , export_path = '.' , verbosity = 1 ) Exponential moving average based on desired two period (or no of days) Parameters: Name Type Description Default ema_canditate Tuple[int, int] Two number used two calculate EMA. Defaults to (50, 200). (50, 200) cutoff_date Union[str, datetime.datetime] Desired date till which to calculate ema. Defaults to \"today\". 'today' save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame EMA and indicators based on it Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_indicator((50,200), '01/06/2020') Source code in stock_analysis/indicator.py def ema_indicator ( self , ema_canditate : Tuple [ int , int ] = ( 50 , 200 ), cutoff_date : Union [ str , datetime . datetime ] = \"today\" , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Exponential moving average based on desired two period (or no of days) Args: ema_canditate (Tuple[int, int], optional): Two number used two calculate EMA. Defaults to (50, 200). cutoff_date (Union[str, datetime.datetime], optional): Desired date till which to calculate ema. Defaults to \"today\". save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. Returns: EMA and indicators based on it Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_indicator((50,200), '01/06/2020') ``` \"\"\" with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_ema_indicator , [ ( company , ema_canditate , cutoff_date , verbosity ) for company in self . data [ \"company\" ] ], ) ema_indicator_df = pd . DataFrame ( result ) ema_indicator_df . dropna ( inplace = True ) ema_indicator_df [ \"percentage_diff\" ] = ema_indicator_df . apply ( lambda x : percentage_diff ( x [ f \"ema { str ( ema_canditate [ 0 ]) } \" ], x [ f \"ema { str ( ema_canditate [ 1 ]) } \" ], return_absolute = True ), axis = 1 , ) ema_indicator_df [ \"outcome\" ] = ema_indicator_df . apply ( lambda x : outcome_analysis ( x [ \"percentage_diff\" ]), axis = 1 ) ema_indicator_df = ema_indicator_df [ [ \"company\" , \"ema_date\" , f \"ema { str ( ema_canditate [ 0 ]) } \" , f \"ema { str ( ema_canditate [ 1 ]) } \" , \"percentage_diff\" , \"outcome\" , \"action\" , ] ] if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { ema_indicator_df . head () } \" ) if save is True : new_folder ( export_path ) ema_indicator_df . to_csv ( f \" { export_path } /ema_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Exported at { export_path } /ema_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" ) else : return ema_indicator_df volume_n_days_indicator ( self , duration = 90 , save = True , export_path = '.' , verbosity = 1 ) Mean Volume Indicator based on desired days Parameters: Name Type Description Default duration int Total days from current date to retrive data. Defaults to 90. 90 save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame All Volume based indicator Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') vol = ind.volume_n_days_indicator(150) Source code in stock_analysis/indicator.py def volume_n_days_indicator ( self , duration : int = 90 , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Mean Volume Indicator based on desired days Args: duration (int, optional): Total days from current date to retrive data. Defaults to 90. save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: All Volume based indicator Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') vol = ind.volume_n_days_indicator(150) ``` \"\"\" with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_vol_indicator_n_days , [( company , duration ) for company in self . data [ \"company\" ]], ) vol_ind_df = pd . DataFrame ( result ) if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { vol_ind_df . head () } \" ) if save is True : new_folder ( export_path ) vol_ind_df . to_csv ( f \" { export_path } /VolumeIndicator90Days_detailed_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Save at { export_path } /VolumeIndicator90Days_detailed_ { now_strting } .csv\" ) else : return vol_ind_df","title":"Indicators"},{"location":"reference/indicators_docs/#stock_analysis.indicator.Indicator-methods","text":"","title":"Methods"},{"location":"reference/indicators_docs/#stock_analysis.indicator.Indicator.ema_crossover_detail_indicator","text":"Exponential moving average for crossover triple period technique Parameters: Name Type Description Default ema_canditate Tuple[int, int, int] Three Period (or days) to calculate EMA. Defaults to (5, 13, 26). (5, 13, 26) save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame Results is based on crossover ema and detailed metrics Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_crossover_detail_indicator((5,10,020), '01/06/2020') Source code in stock_analysis/indicator.py def ema_crossover_detail_indicator ( self , ema_canditate : Tuple [ int , int , int ] = ( 5 , 13 , 26 ), save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Exponential moving average for crossover triple period technique Args: ema_canditate (Tuple[int, int, int], optional): Three Period (or days) to calculate EMA. Defaults to (5, 13, 26). save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: Results is based on crossover ema and detailed metrics Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_crossover_detail_indicator((5,10,020), '01/06/2020') ``` \"\"\" logger . info ( \"Performing EMA Indicator Task\" ) ema_short = self . _ema_indicator_n3 ( ema_canditate = ema_canditate , verbosity = verbosity ) logger . info ( \"Extarcting detail company quote data\" ) batch_company_quote = pd . DataFrame () with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : company_quote = pool . map ( self . unit_quote_retrive , ema_short [ \"company\" ]) for single_company_quote in company_quote : if isinstance ( single_company_quote , pd . DataFrame ): batch_company_quote = batch_company_quote . append ( single_company_quote ) batch_company_quote = batch_company_quote . reset_index () . rename ( columns = { \"index\" : \"company\" } ) batch_company_quote = batch_company_quote [ [ \"company\" , \"longName\" , \"price\" , \"regularMarketVolume\" , \"marketCap\" , \"bookValue\" , \"priceToBook\" , \"averageDailyVolume3Month\" , \"averageDailyVolume10Day\" , \"fiftyTwoWeekLowChange\" , \"fiftyTwoWeekLowChangePercent\" , \"fiftyTwoWeekRange\" , \"fiftyTwoWeekHighChange\" , \"fiftyTwoWeekHighChangePercent\" , \"fiftyTwoWeekLow\" , \"fiftyTwoWeekHigh\" , ] ] batch_company_quote [ \"company\" ] = batch_company_quote [ \"company\" ] . str . replace ( \".NS\" , \"\" ) ema_quote = ema_short . merge ( batch_company_quote , on = \"company\" , validate = \"1:1\" ) if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { ema_quote . head () } \" ) if save is not False : ema_quote . to_csv ( f \" { export_path } /ema_crossover_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } - { str ( ema_canditate [ 2 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Exported at { export_path } /ema_crossover_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } - { str ( ema_canditate [ 2 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" ) else : return ema_quote","title":"ema_crossover_detail_indicator()"},{"location":"reference/indicators_docs/#stock_analysis.indicator.Indicator.ema_detail_indicator","text":"Exponential moving average based on desired two period (or no of days) with additional info which include: regularMarketVolume, marketCap, bookValue, priceToBook, averageDailyVolume3Month, averageDailyVolume10Day, fiftyTwoWeekLowChange, fiftyTwoWeekLowChangePercent, fiftyTwoWeekRange, fiftyTwoWeekHighChange, fiftyTwoWeekHighChangePercent, fiftyTwoWeekLow, fiftyTwoWeekHigh Parameters: Name Type Description Default ema_canditate Tuple[int, int] Two number used two calculate EMA. Defaults to (50, 200). (50, 200) cutoff_date Union[str, datetime.datetime] Desired date till which to calculate ema. Defaults to \"today\". 'today' save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame EMA and detailed metrics for indicators Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_detail_indicator((50,200), '01/06/2020') Source code in stock_analysis/indicator.py def ema_detail_indicator ( self , ema_canditate : Tuple [ int , int ] = ( 50 , 200 ), cutoff_date : Union [ str , datetime . datetime ] = \"today\" , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Exponential moving average based on desired two period (or no of days) with additional info which include: > regularMarketVolume, marketCap, bookValue, priceToBook, averageDailyVolume3Month, averageDailyVolume10Day, fiftyTwoWeekLowChange, fiftyTwoWeekLowChangePercent, fiftyTwoWeekRange, fiftyTwoWeekHighChange, fiftyTwoWeekHighChangePercent, fiftyTwoWeekLow, fiftyTwoWeekHigh Args: ema_canditate (Tuple[int, int], optional): Two number used two calculate EMA. Defaults to (50, 200). cutoff_date (Union[str, datetime.datetime], optional): Desired date till which to calculate ema. Defaults to \"today\". save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. Returns: EMA and detailed metrics for indicators Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_detail_indicator((50,200), '01/06/2020') ``` \"\"\" logger . info ( \"Performing EMA Indicator Task\" ) ema_short = self . ema_indicator ( ema_canditate = ema_canditate , cutoff_date = cutoff_date , save = False , verbosity = verbosity ) logger . info ( \"Extarcting detail company quote data\" ) batch_company_quote = pd . DataFrame () with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : company_quote = pool . map ( self . unit_quote_retrive , ema_short [ \"company\" ]) for single_company_quote in company_quote : if isinstance ( single_company_quote , pd . DataFrame ): batch_company_quote = batch_company_quote . append ( single_company_quote ) batch_company_quote = batch_company_quote . reset_index () . rename ( columns = { \"index\" : \"company\" } ) batch_company_quote = batch_company_quote [ [ \"company\" , \"longName\" , \"price\" , \"regularMarketVolume\" , \"marketCap\" , \"bookValue\" , \"priceToBook\" , \"averageDailyVolume3Month\" , \"averageDailyVolume10Day\" , \"fiftyTwoWeekLowChange\" , \"fiftyTwoWeekLowChangePercent\" , \"fiftyTwoWeekRange\" , \"fiftyTwoWeekHighChange\" , \"fiftyTwoWeekHighChangePercent\" , \"fiftyTwoWeekLow\" , \"fiftyTwoWeekHigh\" , ] ] batch_company_quote [ \"company\" ] = batch_company_quote [ \"company\" ] . str . replace ( \".NS\" , \"\" ) ema_quote = ema_short . merge ( batch_company_quote , on = \"company\" , validate = \"1:1\" ) if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { ema_quote . head () } \" ) if save is not False : ema_quote . to_csv ( f \" { export_path } /ema_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Exported at { export_path } /ema_detail_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" ) else : return ema_quote","title":"ema_detail_indicator()"},{"location":"reference/indicators_docs/#stock_analysis.indicator.Indicator.ema_indicator","text":"Exponential moving average based on desired two period (or no of days) Parameters: Name Type Description Default ema_canditate Tuple[int, int] Two number used two calculate EMA. Defaults to (50, 200). (50, 200) cutoff_date Union[str, datetime.datetime] Desired date till which to calculate ema. Defaults to \"today\". 'today' save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame EMA and indicators based on it Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_indicator((50,200), '01/06/2020') Source code in stock_analysis/indicator.py def ema_indicator ( self , ema_canditate : Tuple [ int , int ] = ( 50 , 200 ), cutoff_date : Union [ str , datetime . datetime ] = \"today\" , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Exponential moving average based on desired two period (or no of days) Args: ema_canditate (Tuple[int, int], optional): Two number used two calculate EMA. Defaults to (50, 200). cutoff_date (Union[str, datetime.datetime], optional): Desired date till which to calculate ema. Defaults to \"today\". save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Detail, 0=Less detail. Defaults to 1. Returns: EMA and indicators based on it Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') ema = ind.ema_indicator((50,200), '01/06/2020') ``` \"\"\" with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_ema_indicator , [ ( company , ema_canditate , cutoff_date , verbosity ) for company in self . data [ \"company\" ] ], ) ema_indicator_df = pd . DataFrame ( result ) ema_indicator_df . dropna ( inplace = True ) ema_indicator_df [ \"percentage_diff\" ] = ema_indicator_df . apply ( lambda x : percentage_diff ( x [ f \"ema { str ( ema_canditate [ 0 ]) } \" ], x [ f \"ema { str ( ema_canditate [ 1 ]) } \" ], return_absolute = True ), axis = 1 , ) ema_indicator_df [ \"outcome\" ] = ema_indicator_df . apply ( lambda x : outcome_analysis ( x [ \"percentage_diff\" ]), axis = 1 ) ema_indicator_df = ema_indicator_df [ [ \"company\" , \"ema_date\" , f \"ema { str ( ema_canditate [ 0 ]) } \" , f \"ema { str ( ema_canditate [ 1 ]) } \" , \"percentage_diff\" , \"outcome\" , \"action\" , ] ] if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { ema_indicator_df . head () } \" ) if save is True : new_folder ( export_path ) ema_indicator_df . to_csv ( f \" { export_path } /ema_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Exported at { export_path } /ema_indicator { str ( ema_canditate [ 0 ]) } - { str ( ema_canditate [ 1 ]) } _ { len ( self . data [ 'company' ]) } company_ { now_strting } .csv\" ) else : return ema_indicator_df","title":"ema_indicator()"},{"location":"reference/indicators_docs/#stock_analysis.indicator.Indicator.volume_n_days_indicator","text":"Mean Volume Indicator based on desired days Parameters: Name Type Description Default duration int Total days from current date to retrive data. Defaults to 90. 90 save bool Save to hard disk. Defaults to True. True export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame All Volume based indicator Examples: from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') vol = ind.volume_n_days_indicator(150) Source code in stock_analysis/indicator.py def volume_n_days_indicator ( self , duration : int = 90 , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"Mean Volume Indicator based on desired days Args: duration (int, optional): Total days from current date to retrive data. Defaults to 90. save (bool, optional): Save to hard disk. Defaults to True. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: All Volume based indicator Example: ```python from stock_analysis.indicator import Indicator ind = Indicator('./data/company_list.yaml') vol = ind.volume_n_days_indicator(150) ``` \"\"\" with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_vol_indicator_n_days , [( company , duration ) for company in self . data [ \"company\" ]], ) vol_ind_df = pd . DataFrame ( result ) if verbosity > 0 : logger . debug ( f \"Here are sample 5 company \\n { vol_ind_df . head () } \" ) if save is True : new_folder ( export_path ) vol_ind_df . to_csv ( f \" { export_path } /VolumeIndicator90Days_detailed_ { now_strting } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Save at { export_path } /VolumeIndicator90Days_detailed_ { now_strting } .csv\" ) else : return vol_ind_df","title":"volume_n_days_indicator()"},{"location":"reference/momentum_docs/","text":"Traders measure momentum in many different ways to identify opportunity pockets. The core idea across all these strategies remains the same i.e to identify momentum and ride the wave. The strategy are combinations of several metrics to determine momentum. Usage: from stock_analysis.momentum_strategy import MomentumStrategy ma = MomentumStrategy('./data/company_list.yaml') Parameters: Name Type Description Default path [str, optional] Path to company yaml/json. Either path or company_name can be used Default to None. required company_name [List, optional] List of company name. If path is used then this is obsolete as 'path' preside over 'company_name'. Default to None. required Methods absolute_momentum_with_dma ( self , end_date = 'today' , period = 200 , cutoff = 5 , save = False , export_path = '.' ) Action determination based on Daily moving average and Turnover Parameters: Name Type Description Default end_date str Latest date to retrive data. Defaults to \"today\". 'today' period int Desired period (in days) for batch SMA calculation. Defaults to 200. 200 cutoff int Desired cutoff to determine action. Defaults to 5. 5 save bool Save to hard disk. Defaults to False. False export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' Returns: Type Description DataFrame Results with action (buy, sell, or no action) including DMA and turnover Example: from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.absolute_momentum_with_dma('01/06/2020', 30) Source code in stock_analysis/momentum_strategy.py def absolute_momentum_with_dma ( self , end_date : str = \"today\" , period : int = 200 , cutoff : int = 5 , save : bool = False , export_path : str = \".\" , ) -> pd . DataFrame : \"\"\"Action determination based on Daily moving average and Turnover Args: end_date (str, optional): Latest date to retrive data. Defaults to \"today\". period (int, optional): Desired period (in days) for batch SMA calculation. Defaults to 200. cutoff (int, optional): Desired cutoff to determine action. Defaults to 5. save (bool, optional): Save to hard disk. Defaults to False. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". Returns: Results with action (buy, sell, or no action) including DMA and turnover Example: ``` from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.absolute_momentum_with_dma('01/06/2020', 30) ``` \"\"\" with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_dma_absolute , [ ( company , end_date , period , cutoff ) for company in self . data [ \"company\" ] ], ) dma_compile = pd . DataFrame ( result ) if save is True : new_folder ( export_path ) if end_date == \"today\" : end_date = now_strting else : end_date = end_date . replace ( \"/\" , \"-\" ) dma_compile . to_csv ( f \" { export_path } /dma_action_cutoff_ { str ( cutoff ) } _ { end_date } .csv\" , index = False , ) else : return dma_compile relative_momentum ( self , end_date = 'today' , top_company_count = 20 , save = True , export_path = '.' , verbosity = 1 ) The strategy is used to identity stocks which had 'good performance' based on desired 'return' duration Parameters: Name Type Description Default end_date str End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. 'today' top_company_count int No of top company to retrieve based on Annualized return. Defaults to 20. 20 save bool Wether to export to disk. Defaults to True. True export_path str Path to export csv.To be used only if 'save' is True. Defaults to '.'. '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame Record based on monthly and yearly calculation Examples: from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') ms = sa.relative_momentum(end_date='01/06/2020') Source code in stock_analysis/momentum_strategy.py def relative_momentum ( self , end_date : str = \"today\" , top_company_count : int = 20 , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"The strategy is used to identity stocks which had 'good performance' based on desired 'return' duration Args: end_date (str, optional): End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. top_company_count (int, optional): No of top company to retrieve based on Annualized return. Defaults to 20. save (bool, optional): Wether to export to disk. Defaults to True. export_path (str, optional): Path to export csv.To be used only if 'save' is True. Defaults to '.'. verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: Record based on monthly and yearly calculation Example: ```python from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') ms = sa.relative_momentum(end_date='01/06/2020') ``` \"\"\" if end_date == \"today\" : end = datetime . datetime . now () else : end = datetime . datetime . strptime ( end_date , \" %d /%m/%Y\" ) . date () start = end - dateutil . relativedelta . relativedelta ( years = 1 ) with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_momentum , [( company , start , end , verbosity ) for company in self . data [ \"company\" ]], ) momentum_df = pd . DataFrame ( result ) momentum_df . dropna ( inplace = True ) momentum_df . sort_values ( by = [ \"return_yearly\" ], ascending = False , inplace = True ) if verbosity > 0 : logger . debug ( f \"Sample output: \\n { momentum_df . head ( top_company_count ) } \" ) if save is True : new_folder ( export_path ) momentum_df . head ( top_company_count ) . to_csv ( f \" { export_path } /momentum_result_ { end . strftime ( ' %d -%m-%Y' ) } _top_ { top_company_count } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Saved at { export_path } /momentum_result_ { end . strftime ( ' %d -%m-%Y' ) } _top_ { top_company_count } .csv\" ) else : return momentum_df . head ( top_company_count ) relative_momentum_with_ema ( self , end_date = 'today' , top_company_count = 20 , ema_canditate = ( 50 , 200 ), save = True , export_path = '.' , verbosity = 1 ) The strategy is used to identity stocks with 'good performance' based on desired 'return' duration and 'exponential moving avg'. Parameters: Name Type Description Default end_date str End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. 'today' top_company_count int No of top company to retrieve based on Annualized return. Defaults to 20. 20 ema_canditate Tuple[int, int] Period (or days) to calculate EMA. Defaults to (50, 200). (50, 200) save bool Wether to export to disk. Defaults to True. True export_path str Path to export csv.To be used only if 'save' is True. Defaults to '.'. '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame Record based on monthly and yearly calculation and EMA calculation Example: from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.relative_momentum_with_ema('01/06/2020', 30) Source code in stock_analysis/momentum_strategy.py def relative_momentum_with_ema ( self , end_date : str = \"today\" , top_company_count : int = 20 , ema_canditate : Tuple [ int , int ] = ( 50 , 200 ), save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"The strategy is used to identity stocks with 'good performance' based on desired 'return' duration and 'exponential moving avg'. Args: end_date (str, optional): End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. top_company_count (int, optional): No of top company to retrieve based on Annualized return. Defaults to 20. ema_canditate (Tuple[int, int], optional): Period (or days) to calculate EMA. Defaults to (50, 200). save (bool, optional): Wether to export to disk. Defaults to True. export_path (str, optional): Path to export csv.To be used only if 'save' is True. Defaults to '.'. verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: Record based on monthly and yearly calculation and EMA calculation Example: ```python from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.relative_momentum_with_ema('01/06/2020', 30) ``` \"\"\" logger . info ( \"Performing Momentum Strategy task\" ) momentum_df = self . relative_momentum ( end_date = end_date , top_company_count = top_company_count , save = False , verbosity = verbosity , ) momentum_df . reset_index ( drop = True , inplace = True ) ind = Indicator ( company_name = momentum_df . loc [:, \"company\" ]) logger . info ( f \"Performing EMA task on top { top_company_count } company till { end_date } \" ) if end_date == \"today\" : cutoff_date = end_date save_date = datetime . datetime . now () . strftime ( \" %d -%m-%Y\" ) else : save_date = end_date . replace ( \"/\" , \"-\" ) cutoff_date = datetime . datetime . strptime ( end_date , \" %d /%m/%Y\" ) assert isinstance ( cutoff_date , datetime . datetime ), \"Incorrect date type\" ema_df = ind . ema_indicator ( ema_canditate = ema_canditate , cutoff_date = cutoff_date , save = False , verbosity = verbosity , ) momentum_ema_df = momentum_df . merge ( ema_df , on = \"company\" , validate = \"1:1\" ) if save is True : new_folder ( export_path ) momentum_ema_df . reset_index ( drop = True , inplace = True ) momentum_ema_df . to_csv ( f \" { export_path } /momentum_ema { ema_canditate [ 0 ] } - { ema_canditate [ 1 ] } _ { save_date } _top_ { top_company_count } .csv\" , index = False , ) logger . debug ( f \"Saved at { export_path } /momentum_ema { ema_canditate [ 0 ] } - { ema_canditate [ 1 ] } _ { save_date } _top_ { top_company_count } .csv\" ) if verbosity > 0 : logger . debug ( f \"Sample output: \\n { momentum_ema_df . head () } \" ) else : return momentum_ema_df","title":"Momentum Strategy"},{"location":"reference/momentum_docs/#stock_analysis.momentum_strategy.MomentumStrategy-methods","text":"","title":"Methods"},{"location":"reference/momentum_docs/#stock_analysis.momentum_strategy.MomentumStrategy.absolute_momentum_with_dma","text":"Action determination based on Daily moving average and Turnover Parameters: Name Type Description Default end_date str Latest date to retrive data. Defaults to \"today\". 'today' period int Desired period (in days) for batch SMA calculation. Defaults to 200. 200 cutoff int Desired cutoff to determine action. Defaults to 5. 5 save bool Save to hard disk. Defaults to False. False export_path str Path to save, to be used only if 'save' is true. Defaults to \".\". '.' Returns: Type Description DataFrame Results with action (buy, sell, or no action) including DMA and turnover Example: from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.absolute_momentum_with_dma('01/06/2020', 30) Source code in stock_analysis/momentum_strategy.py def absolute_momentum_with_dma ( self , end_date : str = \"today\" , period : int = 200 , cutoff : int = 5 , save : bool = False , export_path : str = \".\" , ) -> pd . DataFrame : \"\"\"Action determination based on Daily moving average and Turnover Args: end_date (str, optional): Latest date to retrive data. Defaults to \"today\". period (int, optional): Desired period (in days) for batch SMA calculation. Defaults to 200. cutoff (int, optional): Desired cutoff to determine action. Defaults to 5. save (bool, optional): Save to hard disk. Defaults to False. export_path (str, optional): Path to save, to be used only if 'save' is true. Defaults to \".\". Returns: Results with action (buy, sell, or no action) including DMA and turnover Example: ``` from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.absolute_momentum_with_dma('01/06/2020', 30) ``` \"\"\" with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_dma_absolute , [ ( company , end_date , period , cutoff ) for company in self . data [ \"company\" ] ], ) dma_compile = pd . DataFrame ( result ) if save is True : new_folder ( export_path ) if end_date == \"today\" : end_date = now_strting else : end_date = end_date . replace ( \"/\" , \"-\" ) dma_compile . to_csv ( f \" { export_path } /dma_action_cutoff_ { str ( cutoff ) } _ { end_date } .csv\" , index = False , ) else : return dma_compile","title":"absolute_momentum_with_dma()"},{"location":"reference/momentum_docs/#stock_analysis.momentum_strategy.MomentumStrategy.relative_momentum","text":"The strategy is used to identity stocks which had 'good performance' based on desired 'return' duration Parameters: Name Type Description Default end_date str End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. 'today' top_company_count int No of top company to retrieve based on Annualized return. Defaults to 20. 20 save bool Wether to export to disk. Defaults to True. True export_path str Path to export csv.To be used only if 'save' is True. Defaults to '.'. '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame Record based on monthly and yearly calculation Examples: from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') ms = sa.relative_momentum(end_date='01/06/2020') Source code in stock_analysis/momentum_strategy.py def relative_momentum ( self , end_date : str = \"today\" , top_company_count : int = 20 , save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"The strategy is used to identity stocks which had 'good performance' based on desired 'return' duration Args: end_date (str, optional): End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. top_company_count (int, optional): No of top company to retrieve based on Annualized return. Defaults to 20. save (bool, optional): Wether to export to disk. Defaults to True. export_path (str, optional): Path to export csv.To be used only if 'save' is True. Defaults to '.'. verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: Record based on monthly and yearly calculation Example: ```python from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') ms = sa.relative_momentum(end_date='01/06/2020') ``` \"\"\" if end_date == \"today\" : end = datetime . datetime . now () else : end = datetime . datetime . strptime ( end_date , \" %d /%m/%Y\" ) . date () start = end - dateutil . relativedelta . relativedelta ( years = 1 ) with multiprocessing . Pool ( multiprocessing . cpu_count () - 1 ) as pool : result = pool . starmap ( self . unit_momentum , [( company , start , end , verbosity ) for company in self . data [ \"company\" ]], ) momentum_df = pd . DataFrame ( result ) momentum_df . dropna ( inplace = True ) momentum_df . sort_values ( by = [ \"return_yearly\" ], ascending = False , inplace = True ) if verbosity > 0 : logger . debug ( f \"Sample output: \\n { momentum_df . head ( top_company_count ) } \" ) if save is True : new_folder ( export_path ) momentum_df . head ( top_company_count ) . to_csv ( f \" { export_path } /momentum_result_ { end . strftime ( ' %d -%m-%Y' ) } _top_ { top_company_count } .csv\" , index = False , ) if verbosity > 0 : logger . debug ( f \"Saved at { export_path } /momentum_result_ { end . strftime ( ' %d -%m-%Y' ) } _top_ { top_company_count } .csv\" ) else : return momentum_df . head ( top_company_count )","title":"relative_momentum()"},{"location":"reference/momentum_docs/#stock_analysis.momentum_strategy.MomentumStrategy.relative_momentum_with_ema","text":"The strategy is used to identity stocks with 'good performance' based on desired 'return' duration and 'exponential moving avg'. Parameters: Name Type Description Default end_date str End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. 'today' top_company_count int No of top company to retrieve based on Annualized return. Defaults to 20. 20 ema_canditate Tuple[int, int] Period (or days) to calculate EMA. Defaults to (50, 200). (50, 200) save bool Wether to export to disk. Defaults to True. True export_path str Path to export csv.To be used only if 'save' is True. Defaults to '.'. '.' verbosity int Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. 1 Returns: Type Description DataFrame Record based on monthly and yearly calculation and EMA calculation Example: from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.relative_momentum_with_ema('01/06/2020', 30) Source code in stock_analysis/momentum_strategy.py def relative_momentum_with_ema ( self , end_date : str = \"today\" , top_company_count : int = 20 , ema_canditate : Tuple [ int , int ] = ( 50 , 200 ), save : bool = True , export_path : str = \".\" , verbosity : int = 1 , ) -> pd . DataFrame : \"\"\"The strategy is used to identity stocks with 'good performance' based on desired 'return' duration and 'exponential moving avg'. Args: end_date (str, optional): End date of of stock record to retrive. Must be in format: dd/mm/yyyy. Defaults to 'today'. top_company_count (int, optional): No of top company to retrieve based on Annualized return. Defaults to 20. ema_canditate (Tuple[int, int], optional): Period (or days) to calculate EMA. Defaults to (50, 200). save (bool, optional): Wether to export to disk. Defaults to True. export_path (str, optional): Path to export csv.To be used only if 'save' is True. Defaults to '.'. verbosity (int, optional): Level of detail logging,1=< Deatil, 0=Less detail. Defaults to 1. Returns: Record based on monthly and yearly calculation and EMA calculation Example: ```python from stock_analysis import MomentumStrategy sa = MomentumStrategy('./data/company_list.yaml') mes = sa.relative_momentum_with_ema('01/06/2020', 30) ``` \"\"\" logger . info ( \"Performing Momentum Strategy task\" ) momentum_df = self . relative_momentum ( end_date = end_date , top_company_count = top_company_count , save = False , verbosity = verbosity , ) momentum_df . reset_index ( drop = True , inplace = True ) ind = Indicator ( company_name = momentum_df . loc [:, \"company\" ]) logger . info ( f \"Performing EMA task on top { top_company_count } company till { end_date } \" ) if end_date == \"today\" : cutoff_date = end_date save_date = datetime . datetime . now () . strftime ( \" %d -%m-%Y\" ) else : save_date = end_date . replace ( \"/\" , \"-\" ) cutoff_date = datetime . datetime . strptime ( end_date , \" %d /%m/%Y\" ) assert isinstance ( cutoff_date , datetime . datetime ), \"Incorrect date type\" ema_df = ind . ema_indicator ( ema_canditate = ema_canditate , cutoff_date = cutoff_date , save = False , verbosity = verbosity , ) momentum_ema_df = momentum_df . merge ( ema_df , on = \"company\" , validate = \"1:1\" ) if save is True : new_folder ( export_path ) momentum_ema_df . reset_index ( drop = True , inplace = True ) momentum_ema_df . to_csv ( f \" { export_path } /momentum_ema { ema_canditate [ 0 ] } - { ema_canditate [ 1 ] } _ { save_date } _top_ { top_company_count } .csv\" , index = False , ) logger . debug ( f \"Saved at { export_path } /momentum_ema { ema_canditate [ 0 ] } - { ema_canditate [ 1 ] } _ { save_date } _top_ { top_company_count } .csv\" ) if verbosity > 0 : logger . debug ( f \"Sample output: \\n { momentum_ema_df . head () } \" ) else : return momentum_ema_df","title":"relative_momentum_with_ema()"},{"location":"reference/utils/","text":"Utilities This are all the utilities functions that are needed at various steps Formula Here are all the maths formula needed any stage. Functions annualized_rate_of_return ( end_date , start_date , duration ) Calculate annulized rate of return Parameters: Name Type Description Default end_date int Close value Current date or most present date. Consider it as going from bottom to top. required start_date int Close value on Start date or first record. Consider it as going from bottom to top. required duration float Total duration wrt to year required Returns: Type Description float float: Annulized return Source code in stock_analysis/utils/formula_helpers.py def annualized_rate_of_return ( end_date : int , start_date : int , duration : float ) -> float : \"\"\"Calculate annulized rate of return Args: end_date (int): Close value Current date or most present date. Consider it as going from bottom to top. start_date (int): Close value on Start date or first record. Consider it as going from bottom to top. duration (float): Total duration wrt to year Returns: float: Annulized return \"\"\" return ((( end_date / start_date ) ** ( 1 / duration )) - 1 ) * 100 exponential_moving_average ( data_df , period , cutoff_date = 'today' , smoothing_factor = 2 , verbosity = 1 ) Calculate exponential moving avarage based on given period Parameters: Name Type Description Default data_df Union[pandas.core.series.Series, List] Data to calculate ema required period int Period for which ema has to be calculated required cutoff_date Union[str, datetime.datetime] . Defaults to \"today\". 'today' smoothing_factor int Smoothing factor which will be used to calculate 'Multiplying factor'. Defaults to 2. 2 verbosity int . Defaults to 1. 1 Returns: Type Description float float: ema value Source code in stock_analysis/utils/formula_helpers.py def exponential_moving_average ( data_df : Union [ pd . Series , List ], period : int , cutoff_date : Union [ str , datetime . datetime ] = \"today\" , smoothing_factor : int = 2 , verbosity : int = 1 , ) -> float : \"\"\"Calculate exponential moving avarage based on given period Args: data_df (Union[pd.Series, List]): Data to calculate ema period (int): Period for which ema has to be calculated cutoff_date (Union[str, datetime.datetime], optional): . Defaults to \"today\". smoothing_factor (int, optional): Smoothing factor which will be used to calculate 'Multiplying factor'. Defaults to 2. verbosity (int, optional): . Defaults to 1. Returns: float: ema value \"\"\" ema_list = [] # Calculating multiplying factor mf = smoothing_factor / ( 1 + period ) # Calculating first SMA sma0 = simple_moving_average ( data_df [ \"Close\" ], period ) # Calculating first EMA ema0 = ( data_df [ \"Close\" ][ period ] * mf ) + ( sma0 * ( 1 - mf )) # Calculating latest EMA ema_pre = ema0 for idx in range ( 1 , len ( data_df ) - 50 ): ema = ( data_df [ \"Close\" ][ idx + 50 ] * mf ) + ( ema_pre * ( 1 - mf )) ema_pre = ema ema_list . append ( ema ) # if cutoff_date is not None: if idx == ( len ( data_df ) - 50 ): break data_df [ \"ema\" ] = [ pd . NA ] * ( len ( data_df ) - len ( ema_list )) + ema_list if cutoff_date == \"today\" : date = data_df . index [ - 1 ] else : date = get_appropriate_date_ema ( company_df = data_df , desired_date = cutoff_date , verbosity = verbosity ) return float ( data_df [ data_df . index == date ][ \"ema\" ]) outcome_analysis ( ratio , cutoff = 5 ) Used to determine closeness based on any given ratio analysis like percentage difference Parameters: Name Type Description Default ratio float metrics to determine outcome required cutoff int number to determine outcome. Defaults to 5. 5 Returns: Type Description str str: Outcome of analysis Used to determine closeness based on any given ratio analysis like percentage difference Source code in stock_analysis/utils/formula_helpers.py def outcome_analysis ( ratio : float , cutoff : int = 5 ) -> str : \"\"\"Used to determine closeness based on any given ratio analysis like percentage difference Args: ratio (float): metrics to determine outcome cutoff (int, optional): number to determine outcome. Defaults to 5. Returns: str: Outcome of analysis \"\"\" \"\"\" Used to determine closeness based on any given ratio analysis like percentage difference \"\"\" if cutoff < ratio < cutoff : outcome = \"close by\" else : outcome = \"far away\" return outcome percentage_diff ( value_a , value_b , return_absolute = False ) Used to calculate Percentage difference of Value of B wrt to A. It can be either absolute or not. Parameters: Name Type Description Default value_a float Value a required value_b float Value b required return_absolute bool Return absolute percentage difference False Returns: Type Description float float: percentage difference Source code in stock_analysis/utils/formula_helpers.py def percentage_diff ( value_a : float , value_b : float , return_absolute : bool = False ) -> float : \"\"\"Used to calculate Percentage difference of Value of B wrt to A. It can be either absolute or not. Args: value_a (float): Value a value_b (float): Value b return_absolute (bool): Return absolute percentage difference Returns: float: percentage difference \"\"\" if return_absolute is True : return abs (( value_b - value_a ) / (( value_a + value_b ) / 2 ) * 100 ) elif return_absolute is False : return ( value_b - value_a ) / (( value_a + value_b ) / 2 ) * 100 simple_moving_average ( data , period ) Calculate SMA, which is nothing but calculating mean Parameters: Name Type Description Default data Union[pandas.core.series.Series, List] data on which SMA have to be calculate required period int Total period used to calculate SMA required Returns: Type Description float float: SMA calculated over given period Source code in stock_analysis/utils/formula_helpers.py def simple_moving_average ( data : Union [ pd . Series , List ], period : int ) -> float : \"\"\"Calculate SMA, which is nothing but calculating mean Args: data (Union[pd.Series, List]): data on which SMA have to be calculate period (int): Total period used to calculate SMA Returns: float: SMA calculated over given period \"\"\" return ( sum ( data [: period ])) / period turnover ( volume , price ) Calculate given Stock's batch turnover over specified time Parameters: Name Type Description Default volume Union[pandas.core.series.Series, List] batch volume data required price float price of respective stock required Returns: Type Description float float Source code in stock_analysis/utils/formula_helpers.py def turnover ( volume : Union [ pd . Series , List ], price : float ) -> float : \"\"\"Calculate given Stock's batch turnover over specified time Args: volume (Union[pd.Series, List]): batch volume data price (float): price of respective stock Returns: float \"\"\" return ( sum ( volume ) / len ( volume )) * price General helpers This are general helper functions Functions get_appropriate_date_ema ( company_df , desired_date , verbosity = 1 ) Return appropriate date which is present in data record. Parameters: Name Type Description Default company_df DataFrame Company dataframe required desired_date datetime Desired date cut-off to calculate ema required verbosity int Level of detail logging. Default to 1. 1 Returns: Type Description Tuple[datetime.datetime, float] Tuple[datetime.datetime,float]: Date,Close value on date retrived Exceptions: Type Description ValueError If desired old is older than first record Source code in stock_analysis/utils/helpers.py def get_appropriate_date_ema ( company_df : pd . DataFrame , desired_date : datetime . datetime , verbosity : int = 1 ) -> Tuple [ datetime . datetime , float ]: \"\"\"Return appropriate date which is present in data record. Args: company_df (pd.DataFrame): Company dataframe desired_date (datetime.datetime): Desired date cut-off to calculate ema verbosity ([int, optional]): Level of detail logging. Default to 1. Returns: Tuple[datetime.datetime,float]: Date,Close value on date retrived Raises: ValueError: If desired old is older than first record \"\"\" if desired_date < company_df . index [ 0 ]: logger . error ( f \"Given desired date { desired_date . strftime ( ' %d -%m-%Y' ) } is older than first recorded date { company_df . index [ 0 ] . strftime ( ' %d -%m-%Y' ) } \" ) if verbosity > 0 : logger . debug ( f \"Your desired EMA cut-off date is { desired_date . strftime ( ' %d -%m-%Y' ) } \" ) for day_idx in range ( 1 , 100 ): if desired_date not in company_df . index : date = desired_date - \\ dateutil . relativedelta . relativedelta ( days = day_idx ) else : date = desired_date if date in company_df . index : break if verbosity > 0 and desired_date != date : logger . warning ( f \"Desired date: { desired_date . strftime ( ' %d -%m-%Y' ) } not found going for next possible date: { date . strftime ( ' %d -%m-%Y' ) } \" ) return date get_appropriate_date_momentum ( company_df , company , duration = ( 0 , 1 ), verbosity = 1 ) Return appropriate date which is present in data record. Parameters: Name Type Description Default company_df DataFrame Company dataframe required duration Tuple[int, int] Desired duration to go back to retrive record. Default to (0,1) (0, 1) verbosity int Level of detail logging, 1=< Deatil, 0=Less detail. Default to 1 1 Returns Tuple(datetime.datetime,float): Date,Close value on date retrived Raises ValueError: If desired old is older than first record Source code in stock_analysis/utils/helpers.py def get_appropriate_date_momentum ( company_df : pd . DataFrame , company , duration : Tuple [ int , int ] = ( 0 , 1 ), verbosity : int = 1 ) -> Tuple [ datetime . datetime , float ]: \"\"\"Return appropriate date which is present in data record. Args: company_df (pd.DataFrame): Company dataframe duration (Tuple[year,month], optional): Desired duration to go back to retrive record. Default to (0,1) verbosity (int, optional): Level of detail logging, 1=< Deatil, 0=Less detail. Default to 1 Returns Tuple(datetime.datetime,float): Date,Close value on date retrived Raises ValueError: If desired old is older than first record \"\"\" current_date = company_df . iloc [ - 1 ] . Date desired_date = current_date - \\ dateutil . relativedelta . relativedelta ( years = duration [ 0 ], months = duration [ 1 ]) if desired_date < company_df . iloc [ 0 ] . Date : logger . error ( f \"Given desired date { desired_date . strftime ( ' %d -%m-%Y' ) } is older than first recorded date { company_df . iloc [ 0 ] . Date . strftime ( ' %d -%m-%Y' ) } \" ) raise ValueError dd_copy = desired_date if verbosity > 0 : logger . debug ( f \"Your desired date for monthly return for { company } is { desired_date . strftime ( ' %d -%m-%Y' ) } \" ) if len ( company_df . loc [ company_df [ 'Date' ] == desired_date ]) != 0 : desired_close = company_df . loc [ company_df [ 'Date' ] == desired_date ] else : for i in range ( 1 , 100 ): if len ( company_df . loc [ company_df [ 'Date' ] == desired_date ]) == 0 : desired_date = desired_date - \\ dateutil . relativedelta . relativedelta ( days = i ) desired_close = company_df . loc [ company_df [ 'Date' ] == desired_date ] break if verbosity > 0 : logger . warning ( f \"Desired date: { dd_copy . strftime ( ' %d -%m-%Y' ) } not found going for next possible date: { desired_date . strftime ( ' %d -%m-%Y' ) } \" ) return desired_date , desired_close . iloc [ - 1 ] . Close","title":"Utilities"},{"location":"reference/utils/#utilities","text":"This are all the utilities functions that are needed at various steps","title":"Utilities"},{"location":"reference/utils/#formula","text":"Here are all the maths formula needed any stage.","title":"Formula"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers-functions","text":"","title":"Functions"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers.annualized_rate_of_return","text":"Calculate annulized rate of return Parameters: Name Type Description Default end_date int Close value Current date or most present date. Consider it as going from bottom to top. required start_date int Close value on Start date or first record. Consider it as going from bottom to top. required duration float Total duration wrt to year required Returns: Type Description float float: Annulized return Source code in stock_analysis/utils/formula_helpers.py def annualized_rate_of_return ( end_date : int , start_date : int , duration : float ) -> float : \"\"\"Calculate annulized rate of return Args: end_date (int): Close value Current date or most present date. Consider it as going from bottom to top. start_date (int): Close value on Start date or first record. Consider it as going from bottom to top. duration (float): Total duration wrt to year Returns: float: Annulized return \"\"\" return ((( end_date / start_date ) ** ( 1 / duration )) - 1 ) * 100","title":"annualized_rate_of_return()"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers.exponential_moving_average","text":"Calculate exponential moving avarage based on given period Parameters: Name Type Description Default data_df Union[pandas.core.series.Series, List] Data to calculate ema required period int Period for which ema has to be calculated required cutoff_date Union[str, datetime.datetime] . Defaults to \"today\". 'today' smoothing_factor int Smoothing factor which will be used to calculate 'Multiplying factor'. Defaults to 2. 2 verbosity int . Defaults to 1. 1 Returns: Type Description float float: ema value Source code in stock_analysis/utils/formula_helpers.py def exponential_moving_average ( data_df : Union [ pd . Series , List ], period : int , cutoff_date : Union [ str , datetime . datetime ] = \"today\" , smoothing_factor : int = 2 , verbosity : int = 1 , ) -> float : \"\"\"Calculate exponential moving avarage based on given period Args: data_df (Union[pd.Series, List]): Data to calculate ema period (int): Period for which ema has to be calculated cutoff_date (Union[str, datetime.datetime], optional): . Defaults to \"today\". smoothing_factor (int, optional): Smoothing factor which will be used to calculate 'Multiplying factor'. Defaults to 2. verbosity (int, optional): . Defaults to 1. Returns: float: ema value \"\"\" ema_list = [] # Calculating multiplying factor mf = smoothing_factor / ( 1 + period ) # Calculating first SMA sma0 = simple_moving_average ( data_df [ \"Close\" ], period ) # Calculating first EMA ema0 = ( data_df [ \"Close\" ][ period ] * mf ) + ( sma0 * ( 1 - mf )) # Calculating latest EMA ema_pre = ema0 for idx in range ( 1 , len ( data_df ) - 50 ): ema = ( data_df [ \"Close\" ][ idx + 50 ] * mf ) + ( ema_pre * ( 1 - mf )) ema_pre = ema ema_list . append ( ema ) # if cutoff_date is not None: if idx == ( len ( data_df ) - 50 ): break data_df [ \"ema\" ] = [ pd . NA ] * ( len ( data_df ) - len ( ema_list )) + ema_list if cutoff_date == \"today\" : date = data_df . index [ - 1 ] else : date = get_appropriate_date_ema ( company_df = data_df , desired_date = cutoff_date , verbosity = verbosity ) return float ( data_df [ data_df . index == date ][ \"ema\" ])","title":"exponential_moving_average()"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers.outcome_analysis","text":"Used to determine closeness based on any given ratio analysis like percentage difference Parameters: Name Type Description Default ratio float metrics to determine outcome required cutoff int number to determine outcome. Defaults to 5. 5 Returns: Type Description str str: Outcome of analysis Used to determine closeness based on any given ratio analysis like percentage difference Source code in stock_analysis/utils/formula_helpers.py def outcome_analysis ( ratio : float , cutoff : int = 5 ) -> str : \"\"\"Used to determine closeness based on any given ratio analysis like percentage difference Args: ratio (float): metrics to determine outcome cutoff (int, optional): number to determine outcome. Defaults to 5. Returns: str: Outcome of analysis \"\"\" \"\"\" Used to determine closeness based on any given ratio analysis like percentage difference \"\"\" if cutoff < ratio < cutoff : outcome = \"close by\" else : outcome = \"far away\" return outcome","title":"outcome_analysis()"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers.percentage_diff","text":"Used to calculate Percentage difference of Value of B wrt to A. It can be either absolute or not. Parameters: Name Type Description Default value_a float Value a required value_b float Value b required return_absolute bool Return absolute percentage difference False Returns: Type Description float float: percentage difference Source code in stock_analysis/utils/formula_helpers.py def percentage_diff ( value_a : float , value_b : float , return_absolute : bool = False ) -> float : \"\"\"Used to calculate Percentage difference of Value of B wrt to A. It can be either absolute or not. Args: value_a (float): Value a value_b (float): Value b return_absolute (bool): Return absolute percentage difference Returns: float: percentage difference \"\"\" if return_absolute is True : return abs (( value_b - value_a ) / (( value_a + value_b ) / 2 ) * 100 ) elif return_absolute is False : return ( value_b - value_a ) / (( value_a + value_b ) / 2 ) * 100","title":"percentage_diff()"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers.simple_moving_average","text":"Calculate SMA, which is nothing but calculating mean Parameters: Name Type Description Default data Union[pandas.core.series.Series, List] data on which SMA have to be calculate required period int Total period used to calculate SMA required Returns: Type Description float float: SMA calculated over given period Source code in stock_analysis/utils/formula_helpers.py def simple_moving_average ( data : Union [ pd . Series , List ], period : int ) -> float : \"\"\"Calculate SMA, which is nothing but calculating mean Args: data (Union[pd.Series, List]): data on which SMA have to be calculate period (int): Total period used to calculate SMA Returns: float: SMA calculated over given period \"\"\" return ( sum ( data [: period ])) / period","title":"simple_moving_average()"},{"location":"reference/utils/#stock_analysis.utils.formula_helpers.turnover","text":"Calculate given Stock's batch turnover over specified time Parameters: Name Type Description Default volume Union[pandas.core.series.Series, List] batch volume data required price float price of respective stock required Returns: Type Description float float Source code in stock_analysis/utils/formula_helpers.py def turnover ( volume : Union [ pd . Series , List ], price : float ) -> float : \"\"\"Calculate given Stock's batch turnover over specified time Args: volume (Union[pd.Series, List]): batch volume data price (float): price of respective stock Returns: float \"\"\" return ( sum ( volume ) / len ( volume )) * price","title":"turnover()"},{"location":"reference/utils/#general-helpers","text":"This are general helper functions","title":"General helpers"},{"location":"reference/utils/#stock_analysis.utils.helpers-functions","text":"","title":"Functions"},{"location":"reference/utils/#stock_analysis.utils.helpers.get_appropriate_date_ema","text":"Return appropriate date which is present in data record. Parameters: Name Type Description Default company_df DataFrame Company dataframe required desired_date datetime Desired date cut-off to calculate ema required verbosity int Level of detail logging. Default to 1. 1 Returns: Type Description Tuple[datetime.datetime, float] Tuple[datetime.datetime,float]: Date,Close value on date retrived Exceptions: Type Description ValueError If desired old is older than first record Source code in stock_analysis/utils/helpers.py def get_appropriate_date_ema ( company_df : pd . DataFrame , desired_date : datetime . datetime , verbosity : int = 1 ) -> Tuple [ datetime . datetime , float ]: \"\"\"Return appropriate date which is present in data record. Args: company_df (pd.DataFrame): Company dataframe desired_date (datetime.datetime): Desired date cut-off to calculate ema verbosity ([int, optional]): Level of detail logging. Default to 1. Returns: Tuple[datetime.datetime,float]: Date,Close value on date retrived Raises: ValueError: If desired old is older than first record \"\"\" if desired_date < company_df . index [ 0 ]: logger . error ( f \"Given desired date { desired_date . strftime ( ' %d -%m-%Y' ) } is older than first recorded date { company_df . index [ 0 ] . strftime ( ' %d -%m-%Y' ) } \" ) if verbosity > 0 : logger . debug ( f \"Your desired EMA cut-off date is { desired_date . strftime ( ' %d -%m-%Y' ) } \" ) for day_idx in range ( 1 , 100 ): if desired_date not in company_df . index : date = desired_date - \\ dateutil . relativedelta . relativedelta ( days = day_idx ) else : date = desired_date if date in company_df . index : break if verbosity > 0 and desired_date != date : logger . warning ( f \"Desired date: { desired_date . strftime ( ' %d -%m-%Y' ) } not found going for next possible date: { date . strftime ( ' %d -%m-%Y' ) } \" ) return date","title":"get_appropriate_date_ema()"},{"location":"reference/utils/#stock_analysis.utils.helpers.get_appropriate_date_momentum","text":"Return appropriate date which is present in data record. Parameters: Name Type Description Default company_df DataFrame Company dataframe required duration Tuple[int, int] Desired duration to go back to retrive record. Default to (0,1) (0, 1) verbosity int Level of detail logging, 1=< Deatil, 0=Less detail. Default to 1 1 Returns Tuple(datetime.datetime,float): Date,Close value on date retrived Raises ValueError: If desired old is older than first record Source code in stock_analysis/utils/helpers.py def get_appropriate_date_momentum ( company_df : pd . DataFrame , company , duration : Tuple [ int , int ] = ( 0 , 1 ), verbosity : int = 1 ) -> Tuple [ datetime . datetime , float ]: \"\"\"Return appropriate date which is present in data record. Args: company_df (pd.DataFrame): Company dataframe duration (Tuple[year,month], optional): Desired duration to go back to retrive record. Default to (0,1) verbosity (int, optional): Level of detail logging, 1=< Deatil, 0=Less detail. Default to 1 Returns Tuple(datetime.datetime,float): Date,Close value on date retrived Raises ValueError: If desired old is older than first record \"\"\" current_date = company_df . iloc [ - 1 ] . Date desired_date = current_date - \\ dateutil . relativedelta . relativedelta ( years = duration [ 0 ], months = duration [ 1 ]) if desired_date < company_df . iloc [ 0 ] . Date : logger . error ( f \"Given desired date { desired_date . strftime ( ' %d -%m-%Y' ) } is older than first recorded date { company_df . iloc [ 0 ] . Date . strftime ( ' %d -%m-%Y' ) } \" ) raise ValueError dd_copy = desired_date if verbosity > 0 : logger . debug ( f \"Your desired date for monthly return for { company } is { desired_date . strftime ( ' %d -%m-%Y' ) } \" ) if len ( company_df . loc [ company_df [ 'Date' ] == desired_date ]) != 0 : desired_close = company_df . loc [ company_df [ 'Date' ] == desired_date ] else : for i in range ( 1 , 100 ): if len ( company_df . loc [ company_df [ 'Date' ] == desired_date ]) == 0 : desired_date = desired_date - \\ dateutil . relativedelta . relativedelta ( days = i ) desired_close = company_df . loc [ company_df [ 'Date' ] == desired_date ] break if verbosity > 0 : logger . warning ( f \"Desired date: { dd_copy . strftime ( ' %d -%m-%Y' ) } not found going for next possible date: { desired_date . strftime ( ' %d -%m-%Y' ) } \" ) return desired_date , desired_close . iloc [ - 1 ] . Close","title":"get_appropriate_date_momentum()"},{"location":"reference/web_app/","text":"","title":"Usage"},{"location":"theory/generic_term/","text":"","title":"Generic Terminology"},{"location":"theory/prac_usage/","text":"","title":"Practical Usage"}]}